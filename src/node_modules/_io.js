/**
 * ChirpOS - File System
 * @author Cawdabra
 * @license MIT
 */
"use strict";

require("../globals.js");
const os = require("_os");

// Namespace
var io = {};

// Default file stream buffer size
const DEFAULT_BUFFER_SIZE = 1024;

/**
 * File system node flags
 * @enum
 */
io.FileFlag = {
    SYSTEM:       1 << 0,
    EXECUTABLE:   1 << 1,
    HIDDEN:       1 << 2,
    SUPER_HIDDEN: 1 << 3        // Always hidden to the user no matter what
};

/**
 * File system info class
 * @class
 * @param {number} capacity
 */
io.FileSystemInfo = function(capacity) {
    this.capacity = capacity;
};

/**
 * File system class
 * @class
 * @param {FileSystemInfo} [info]
 */
io.FileSystem = function(info) {
    if (info instanceof io.FileSystemInfo) {
        this.info = info;
    }
    else {
        this.info = new io.FileSystemInfo(os.FILE_SYSTEM_CAPACITY);
    }

    this._root = new io.Directory(this, new io.FileSystemNodeInfo(os.ROOT_DIR_NAME));
};

/**
 * Returns the root directory of the file system
 * @return {Directory}
 */
io.FileSystem.prototype.getRoot = function() {
    return this._root;
};

/**
 * Returns a node from a path string
 * @param {string} path
 * @return {StatusObject}
 */
io.FileSystem.prototype.getNodeFromPath = function(path) {
    var split = path.split(os.path.DIR_SEPARATOR);
    var node = this._root;
    var i, status;
    for (i=1; i<split.length; ++i) {
        if (split[i] === "") {
            // Ignore blank entries (double separators will cause this for instance)
            continue;
        }

        status = node.getNode(split[i]);
        if (!status.isSuccess()) {
            return status;
        }

        node = status.result;
    }

    return new StatusObject(StatusCode.SUCCESS, node);
};

/**
 * Info class for file system nodes
 * @class
 * @param {string} name
 * @param {number} [created]
 * @param {number} [modified]
 * @param {number} [accessed]
 * @param {number} [flags]
 */
io.FileSystemNodeInfo = function(name, created, modified, accessed, flags) {
    this.name = name;
    const time = Date.now();
    this.created = (typeof created === "number") ? created : time;
    this.modified = (typeof modified === "number") ? modified : time;
    this.accessed = (typeof accessed === "number") ? accessed : time;
    this.flags = (typeof flags === "number") ? flags : 0;
};

/**
 * File system node class
 * @class
 * @abstract
 * @param {FileSystemNode} parent
 * @param {FileSystemNodeInfo} info
 */
io.FileSystemNode = function(parent, info) {
    this.parent = parent;
    this.info = info;
};

/**
 * Returns the absolute path string of this node
 * @return {string}
 */
io.FileSystemNode.prototype.getPath = function() {
    var path_array = [this.info.name];
    var root = this.parent;
    while (!(root instanceof io.FileSystem)) {
        path_array.unshift(root.info.name);
        root = root.parent;
    }

    var path = path_array.join(os.path.DIR_SEPARATOR).trim();
    if (path === "") {
        // Never give an empty path (path of root when root has no name)
        path = os.path.DIR_SEPARATOR;
    }
    return path;
};

/**
 * Returns all of the nodes of the absolute path for this node
 * @return {Array}
 */
io.FileSystemNode.prototype.getPathNodes = function() {
    var path_array = [this];
    var root = this.parent;
    while (!(root instanceof io.FileSystem)) {
        path_array.unshift(root);
        root = root.parent;
    }
    return path_array;
};

/**
 * Sets a flag for the node
 * @param {FileSystemNodeFlag}
 */
io.FileSystemNode.prototype.setFlag = function(flag) {
    this.info.flags |= flag;
};

/**
 * Unsets a flag for the node
 * @param {FileSystemNodeFlag}
 */
io.FileSystemNode.prototype.unsetFlag = function(flag) {
    this.info.flags &= ~flag;
};

/**
 * Checks if the node has a flag set
 * @param {FileSystemNodeFlag}
 * @return {boolean}
 */
io.FileSystemNode.prototype.hasFlag = function(flag) {
    return (this.info.flags & flag) ? true : false;
};

/**
 * Directory class
 * @class
 * @extends FileSystemNode
 * @param {Directory|FileSystem} parent
 * @param {FileSystemNodeInfo} info
 */
io.Directory = function(parent, info) {
    io.FileSystemNode.call(this, parent, info);
    this._children = {};
};
inheritClass(io.Directory, io.FileSystemNode);

/**
 * Returns a result object containing a child file system node
 * @param {string} filename
 * @return {StatusObject}
 */
io.Directory.prototype.getNode = function(filename) {
    if (this._children.hasOwnProperty(filename)) {
        return new StatusObject(StatusCode.SUCCESS, this._children[filename]);
    }

    return new StatusObject(StatusCode.FILE_NOT_FOUND);
};

/**
 * Returns the children of the directory
 * @return {object}
 */
io.Directory.prototype.getChildren = function() {
    return this._children;
}

/**
 * Sets or adds a child node to the directory
 * @param {FileSystemNode} node
 * @param {boolean} [user_mode]
 * @return {StatusCode}
 */
io.Directory.prototype.setNode = function(node, user_mode) {
    if (user_mode && this.hasFlag(io.FileFlag.SYSTEM)) {
        return StatusCode.PERMISSION_DENIED;
    }

    this._children[node.info.name] = node;
    return StatusCode.SUCCESS;
};

/**
 * Deletes a node
 * @param {string} filename
 * @param {boolean} [user_mode]
 * @return {StatusCode}
 */
io.Directory.prototype.deleteNode = function(filename, user_mode) {
    if (this._children.hasOwnProperty(filename)) {
        if (user_mode && (this.hasFlag(io.FileFlag.SYSTEM) || this._children[filename].hasFlag(io.FileFlag.SYSTEM)) ) {
            return StatusCode.PERMISSION_DENIED;
        }

        delete this._children[filename];
        return StatusCode.SUCCESS;
    }

    return StatusCode.FILE_NOT_FOUND;
};

/**
 * File class
 * @class
 * @extends FileSystemNode
 * @param {Directory} parent
 * @param {FileSystemNodeInfo} info
 * @param {string} [data]
 */
io.File = function(parent, info, data) {
    io.FileSystemNode.call(this, parent, info);
    this.data = (typeof data === "string") ? data : "";
};
inheritClass(io.File, io.FileSystemNode);

/**
 * File stream class
 * @class
 * @param {Kernel} kernel
 * @param {number} pid
 * @param {File} file
 * @param {string} mode
 */
io.FileStream = function(kernel, pid, file, mode) {
    this._kernel = kernel;
    this._pid = pid;
    this._file = file;
    this._mode = mode;
    this._bufferSize = os.FILE_STREAM_BUFFER_SIZE;
    this._buffer = "";
    this._position = 0;
    this._isClosed = false;
};

/**
 * Closes the stream
 * @return {StatusCode}
 */
io.FileStream.prototype.close = function() {
    if (this._isClosed) {
        return StatusCode.STREAM_IS_CLOSED;
    }

    if (this._mode.indexOf("w") > -1 || this._mode.indexOf("a") > -1 && this._buffer.length > 0) {
        var status = this.flush();
        if (status !== StatusCode.SUCCESS) {
            return status;
        }
    }

    this._isClosed = true;
    return StatusCode.SUCCESS;
};

/**
 * Returns the size of the buffer
 * @return {number}
 */
io.FileStream.prototype.getBufferSize = function() {
    return this._bufferSize;
};

/**
 * Sets the size of the buffer
 * @param {number} size
 */
io.FileStream.prototype.setBufferSize = function(size) {
    this._bufferSize = size;
};

/**
 * Returns the mode of the file stream
 * @return {string}
 */
io.FileStream.prototype.getMode = function() {
    return this._mode;
};

/**
 * Sets the position of the stream
 * @param {number} pos
 */
io.FileStream.prototype.seek = function(pos) {
    var data_length = this._file.data.length;
    if (data_length >= pos && pos > -1) {
        this._position = pos;
    }
    else {
        this._position = data_length;
    }
};

/**
 * Tells the current stream position
 * @return {number}
 */
io.FileStream.prototype.tell = function() {
    return this._position;
};

/**
 * Returns a specified amount of characters starting at the current stream position
 * @param {number} size
 * @return {StatusObject}
 */
io.FileStream.prototype.read = function(size) {
    if (this._mode.indexOf("r") === -1) {
        return new StatusObject(StatusCode.STREAM_NOT_IN_READ_MODE);
    }

    if (this._isClosed) {
        return new StatusObject(StatusCode.STREAM_IS_CLOSED);
    }

    if (this._file.hasFlag(io.FileFlag.SYSTEM)) {
        return new StatusObject(StatusCode.PERMISSION_DENIED);
    }

    if (!this._kernel.canReadFromFile(this._pid, this._file)) {
        return new StatusObject(StatusCode.FILE_IS_READ_LOCKED);
    }

    var data = this._file.data.substr(this._position, size);
    this.seek(this._position + size);
    return new StatusObject(StatusCode.SUCESS, data);
};

/**
 * Returns a string starting at the current stream position up until it reaches
 * the end of the line or the end of the stream
 * @return {StatusObject}
 */
io.FileStream.prototype.readLine = function() {
    if (this._mode.indexOf("r") === -1) {
        return new StatusObject(StatusCode.STREAM_NOT_IN_READ_MODE);
    }

    if (this._isClosed) {
        return new StatusObject(StatusCode.STREAM_IS_CLOSED);
    }

    if (this._file.hasFlag(io.FileFlag.SYSTEM)) {
        return new StatusObject(StatusCode.PERMISSION_DENIED);
    }

    if (!this._kernel.canReadFromFile(this._pid, this._file)) {
        return new StatusObject(StatusCode.FILE_IS_READ_LOCKED);
    }

    var old_pos = this._position;
    var pos = this._file.data.substr(old_pos).indexOf("\n");
    if (pos > -1) {
        // Offset to include newline character
        pos += old_pos + 1;
    }
    else {
        pos = this._file.data.length;
    }

    this.seek(pos);
    return new StatusObject(StatusCode.SUCCESS, this._file.data.substring(old_pos, pos));
};

/**
 * Writes a string to the stream
 * @param {string} data
 * @return {StatusCode}
 */
io.FileStream.prototype.write = function(data) {
    if (this._mode.indexOf("w") === -1 && this._mode.indexOf("a") === -1) {
        return new StatusObject(StatusCode.STREAM_NOT_IN_WRITE_MODE);
    }

    if (this._isClosed) {
        return new StatusObject(StatusCode.STREAM_IS_CLOSED);
    }

    // In case the combined data is longer than the buffer size, it should be
    // flushed as many times as needed. However, to save the expense of compressing
    // and storing to local storage, I'm going to temporarily go past the buffer
    // size and flush it all in one shot.
    var old_buffer = this._buffer;      // Store the old value in case of failure
    var combined_length = this._buffer.length + data.length;
    var flush_length = Math.floor(combined_length / this._bufferSize) * this._bufferSize;
    if (flush_length > 0) {
        this._buffer = (this._buffer + data).substr(0, flush_length);
        var result = this.flush();
        if (result !== StatusCode.SUCCESS) {
            this._buffer = old_buffer;
            return result;
        }
    }

    this._buffer = (this._buffer + data).substr(flush_length);
    this.seek(this._file.length + combined_length);
    return StatusCode.SUCESS;
};

/**
 * Writes a line to the stream
 * @param {string} data
 * @return {StatusCode}
 */
io.FileStream.prototype.writeLine = function(data) {
    return this.write(data + "\n");
};

/**
 * Flushes the write buffer
 * @return {StatusCode}
 */
io.FileStream.prototype.flush = function() {
    if (this._file.hasFlag(io.FileFlag.SYSTEM)) {
        return StatusCode.PERMISSION_DENIED;
    }

    return this._kernel.write(this._pid, this._file, this._buffer);
};

module.exports = io;
