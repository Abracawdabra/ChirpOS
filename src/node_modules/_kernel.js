/**
 * ChirpOS - Kernel Module
 * @author Cawdabra
 * @license MIT
 */
"use strict";

require("../globals.js");
const os = require("_os");
const log = require("_log");
const io = require("_io");

// Namespace
var kernel = {};

/**
 * Kernel class
 * @class
 */
kernel.Kernel = function() {
    this.loggerInstance = new log.Logger(log.LogLevel.DEBUG);
    log.addLoggerMethod(this);

    this._fileSystem = new io.FileSystem();
    this._fileLocks = {
        0: {}       // Kernel
    };
};

/**
 * Returns the file system
 * @return {io.FileSystem}
 */
kernel.Kernel.prototype.getFileSystem = function() {
    return this._fileSystem;
};

/**
 * Returns all locks on a file and its parents
 * @param {io.File} file
 * @return {object}
 */
kernel.Kernel.prototype.findFileLocks = function(file) {
    var path = file.getPath();

    // Cache the node paths
    var file_path = file.getPath();
    var paths = [];
    var i;
    while (file_path !== "" && file_path !== os.path.DIR_SEPARATOR) {
        paths.push(file_path);
        file_path = os.path.getDirName(file_path);
    }

    var locks = {};
    var pid_key, path_iter;
    for (pid_key in this._fileLocks) {
        if (this._fileLocks.hasOwnProperty(pid_key)) {
            for (path_iter=0; path_iter<paths.length; ++path_iter) {
                path = paths[path_iter];
                if (this._fileLocks[pid_key].hasOwnProperty(path)) {
                    if (locks.hasOwnProperty(pid_key)) {
                        locks[pid_key][path] = this._fileLocks[pid_key][path];
                    }
                    else {
                        locks[pid_key] = {};
                        locks[pid_key][path] = this._fileLocks[pid_key][path];
                    }
                }
            }
        }
    }

    return locks;
};

/**
 * Checks for any read locks on a file or its parents
 * @param {number} pid The process ID to exclude from the search
 * @param {io.File} file
 * @return {boolean}
 */
kernel.Kernel.prototype.canReadFrom = function(pid, file) {
    // Keys get converted to strings automatically during assignment
    pid = pid.toString();

    var locks = this.findFileLocks(file);
    var pid_key, path_key;
    for (pid_key in locks) {
        if (pid_key !== pid && locks.hasOwnProperty(pid_key)) {
            for (path_key in locks[pid_key]) {
                if (locks[pid_key].hasOwnProperty(path_key) && locks[pid_key][path_key].read) {
                    return false;
                }
            }
        }
    }

    return true;
};

/**
 * Checks for any write locks on a file or its parents
 * @param {number} pid The process ID to exclude from the search
 * @param {io.File} file
 * @return {boolean}
 */
kernel.Kernel.prototype.canWriteTo = function(pid, file) {
    // Keys get converted to strings automatically during assignment
    pid = pid.toString();

    var locks = this.findFileLocks(file);
    var pid_key, path_key;
    for (pid_key in locks) {
        if (pid_key !== pid && locks.hasOwnProperty(pid_key)) {
            for (path_key in locks[pid_key]) {
                if (locks[pid_key].hasOwnProperty(path_key) && locks[pid_key][path_key].write) {
                    return false;
                }
            }
        }
    }

    return true;
};

/**
 * Attempts to read lock a file
 * @param {number} pid
 * @param {io.File} file
 * @param {boolean} lock
 * @return {StatusCode}
 */
kernel.Kernel.prototype.readLockFile = function(pid, file, lock) {
    // Keys get converted to strings automatically during assignment
    pid = pid.toString();

    var locks = this.findFileLocks(file);
    var pid_key, path_key;
    for (pid_key in locks) {
        if (pid_key !== pid && locks.hasOwnProperty(pid_key)) {
            for (path_key in locks[pid_key]) {
                if (locks[pid_key].hasOwnProperty(path_key) && locks[pid_key][path_key].read) {
                    return StatusCode.FILE_IS_READ_LOCKED;
                }
            }
        }
    }

    var path = file.getPath();
    if (locks.hasOwnProperty(pid)) {
        if (locks[pid].hasOwnProperty(path)) {
            locks[pid][path].read = lock;
        }
        else {
            // New entry
            locks[pid][path] = {
                read: lock,
                write: false
            };
        }
        this.logger().info("Kernel", "Process #" + pid + " updated lock for: '" + path + "', read=" + lock + ", write=" + locks[pid][path].write);
    }
    else {
        // New entry
        var path = file.getPath();
        this._fileLocks[pid] = {};
        this._fileLocks[pid][path] = {
            read: lock,
            write: false
        };
        this.logger().info("Kernel", "Process #" + pid + " obtained lock for: '" + path + "', read=" + lock + ", write=" + false);
    }

    return StatusCode.SUCCESS;
};

/**
 * Attempts to write lock a file
 * @param {number} pid
 * @param {io.FIle} file
 * @param {boolean} lock
 * @return {StatusCode}
 */
kernel.Kernel.prototype.writeLockFile = function(pid, file, lock) {
    // Keys get converted to strings automatically during assignment
    pid = pid.toString();

    var locks = this.findFileLocks(file);
    var pid_key, path_key;
    for (pid_key in locks) {
        if (pid_key !== pid && locks.hasOwnProperty(pid_key)) {
            for (path_key in locks[pid_key]) {
                if (locks[pid_key].hasOwnProperty(path_key) && locks[pid_key][path_key].write) {
                    return StatusCode.FILE_IS_WRITE_LOCKED;
                }
            }
        }
    }

    var path = file.getPath();
    if (locks.hasOwnProperty(pid)) {
        if (locks[pid].hasOwnProperty(path)) {
            locks[pid][path].write = lock;
        }
        else {
            // New entry
            locks[pid][path] = {
                read: false,
                write: lock
            };
        }
        this.logger().info("Kernel", "Process #" + pid + " updated lock for: '" + path + "', read=" + locks[pid][path].read + ", write=" + lock);
    }
    else {
        // New entry
        this._fileLocks[pid] = {};
        this._fileLocks[pid][path] = {
            read: false,
            write: lock
        };
        this.logger().info("Kernel", "Process #" + pid + " obtained lock for: '" + path + "', read=" + false + ", write=" + lock);
    }

    return StatusCode.SUCCESS;
};

/**
 * Deletes a file lock
 * @param {number} pid
 * @param {io.File} file
 * @return {StatusCode}
 */
kernel.Kernel.prototype.deleteFileLock = function(pid, file) {
    var path = file.getPath();
    if (!this._fileLocks.hasOwnProperty(pid) || !this._fileLocks[pid].hasOwnProperty(path)) {
        return StatusCode.FILE_LOCK_NOT_FOUND;
    }

    this.logger().info("Deleting lock for process: #" + pid + ", file='" + path + "'");
    delete this._fileLocks[pid][path];

    // Delete the entire object if there's no file locks in it
    var file_key;
    var delete_object = true;
    for (file_key in this._fileLocks[pid]) {
        if (this._fileLocks[pid].hasOwnProperty(file_key)) {
            delete_object = false;
            break;
        }
    }

    if (delete_object) {
        this.logger().info("Process #" + pid + " has no file locks. Deleting object.");
        delete this._fileLocks[pid];
    }

    return StatusCode.SUCCESS;
}

/**
 * Creates a new file in the file system
 * @param {number} pid Process ID
 * @param {string} path
 * @param {number} flags
 * @param {boolean} user_mode
 * @return {StatusObject}
 */
kernel.Kernel.prototype.createFile = function(pid, path, flags, user_mode) {
    var dir_name = os.path.getDirName(path);
    var status = this._fileSystem.getNodeFromPath(dir_name);
    if (!status.isSuccess()) {
        // Parent directory not found
        return status;
    }

    var parent = status.result;
    if (!(parent instanceof io.Directory)) {
        // Parent is not a directory
        return new StatusObject(StatusCode.NODE_IS_NOT_DIRECTORY, "Node '" + dir_name + "' is not a directory");
    }

    if (user_mode && parent.hasFlag(io.FileFlag.SYSTEM)) {
        return new StatusObject(StatusCode.PERMISSION_DENIED);
    }

    if (user_mode && !this.canWriteTo(pid, parent)) {
        return new StatusObject(StatusCode.FILE_IS_WRITE_LOCKED, "Parent directory '" + dir_name + "' is write locked");
    }

    var file = new io.File(parent, new io.FileSystemNodeInfo(os.path.getBaseName(path), 0, 0, 0, flags));
    status = parent.setNode(file, user_mode);
    if (status !== StatusCode.SUCCESS) {
        return new StatusObject(status);
    }

    this.logger().info("Kernel", "Process #" + pid + " created file: '" + path + "'");
    return new StatusObject(StatusCode.SUCCESS, file);;
};

/**
 * Attempts to create as many directories as necessary to reach the end of the path
 * @param {number} pid Process ID
 * @param {string} path
 * @param {number} flags
 * @param {boolean} user_mode User mode induces permission and lock checks
 * @return {StatusObject}
 */
kernel.Kernel.prototype.makeDirs = function(pid, path, flags, user_mode) {
    this.logger().info("Kernel", "Creating directories for path: '" + path + "'");
    var split = path.split(os.path.DIR_SEPARATOR);
    var i, dir, status;
    var parent = this._fileSystem.getRoot();
    for (i=1; i<split.length; ++i) {
        // Traverse the path
        status = this._fileSystem.getNodeFromPath(split.slice(0, i + 1).join(os.path.DIR_SEPARATOR));
        if (status.code === StatusCode.SUCCESS) {
            parent = status.result;
            if (!(parent instanceof io.Directory)) {
                // Parent is not a directory
                return new StatusObject(StatusCode.NODE_IS_NOT_DIRECTORY, "Node '" + split[i] + "' is not a directory");
            }
        }
        else {
            // Not found
            this.logger().debug("Kernel", "Creating directory: '" + split[i] + "'");
            if (user_mode && !this.canWriteTo(pid, parent)) {
                return new StatusObject(StatusCode.FILE_IS_WRITE_LOCKED);
            }

            dir = new io.Directory(parent, new io.FileSystemNodeInfo(split[i], 0, 0, 0, flags));
            status = parent.setNode(dir, user_mode);
            if (status !== StatusCode.SUCCESS) {
                // Cannot continue any further
                return new StatusObject(status);
            }

            parent = dir;
        }
    }

    return new StatusObject(StatusCode.SUCCESS, dir);
};

/**
 * Returns a file stream to a file
 * @param {number} pid Process ID
 * @param {string} path
 * @param {string} mode "r" = read, "w" = write, "a" = append
 * @param {boolean} user_mode User mode induces permission checks
 * @return {StatusObject}
 */
kernel.Kernel.prototype.openFile = function(pid, path, mode, user_mode) {
    this.logger().info("Process #" + pid + " attempting to open file '" + path + "'");
    var status = this._fileSystem.getNodeFromPath(path);
    if (!status.isSuccess()) {
        if ((mode.indexOf("w") > -1 || mode.indexOf("a") > -1) && status.code === StatusCode.FILE_NOT_FOUND) {
            // Create new file
            status = this.createFile(pid, path, 0, user_mode);
            if (!status.isSuccess()) {
                return status;
            }
        }
        else {
            return status;
        }
    }

    var file = status.result;
    if (user_mode) {
        if (file.hasFlag(io.FileFlag.SYSTEM)) {
            return new StatusObject(StatusCode.PERMISSION_DENIED);
        }

        if (mode.indexOf("r") > -1 && !this.canReadFrom(pid, file)) {
            return new StatusObject(StatusCode.FILE_IS_READ_LOCKED);
        }

        if ((mode.indexOf("w") > -1 || mode.indexOf("a") > -1) && !this.canWriteTo(pid, file)) {
            return new StatusObject(StatusCode.FILE_IS_WRITE_LOCKED);
        }
    }

    return new StatusObject(StatusCode.SUCCESS, new io.FileStream(this, pid, file, mode));
};

module.exports = kernel;
